import fs from "fs";
import path from "path";

async function main() {
  const [, ...args] = process.argv;

  const namedArgs = parseNamedArgs(args);

  const outputArg = namedArgs.get("output");
  const versionArg = namedArgs.get("version");

  try {
    if (outputArg === undefined) {
      throw new Error("No output file specified");
    }

    const contents = await downloadDerivedCoreProperties(versionArg);

    console.info("Extracting data from file...");

    const startCodePoints = extractDerivedCoreProperties(contents, "ID_Start");
    const continueCodePoints = extractDerivedCoreProperties(
      contents,
      "ID_Continue"
    );

    console.info("Data extracted from file");

    const version = extractVersion(contents);

    if (version === null) {
      throw new Error("Version not found in output file");
    }

    writeRustFile({
      continueCodePoints,
      output: outputArg,
      startCodePoints,
      version,
    });
  } catch (e) {
    throw e;
  }
}

main();

function parseNamedArgs(args: string[]) {
  const namedArgs: Map<string, string> = new Map();

  for (const arg of args.slice(1)) {
    if (arg.startsWith("--") || arg.startsWith("-")) {
      const [key, value] = arg.split("=");

      switch (key) {
        case "--version":
        case "-v":
          namedArgs.set("version", value);
        case "--output":
        case "-o":
          namedArgs.set("output", value);
      }
    }
  }

  return namedArgs;
}

// Download and extract data.

async function downloadDerivedCoreProperties(
  version: string | null | undefined = "UNIDATA"
): Promise<string> {
  const BASEURL = "https://unicode.org/Public";
  const FILENAME = "DerivedCoreProperties.txt";

  const url =
    version === "UNIDATA"
      ? `${BASEURL}/${version}/${FILENAME}`
      : `${BASEURL}/${version}/ucd/${FILENAME}`;

  try {
    console.info(`Downloading \`${url}\`...`);

    const response = await fetch(url);

    const text = await response.text();

    console.info(`Finished downloading \`${url}\``);

    return text;
  } catch (e) {
    throw e;
  }
}

function extractDerivedCoreProperties(
  fileContents: string,
  derivedProperty: string
): Set<string> {
  let codePoints = new Set<string>();

  const rows = fileContents.split("\n");

  for (let row of rows) {
    // Continue if the line is empty or is a comment.
    if (row === "" || row.startsWith("#")) {
      continue;
    }

    let [codePointRange, property] = row.split("#")[0].split(";");

    codePointRange = codePointRange.trim();
    property = property.trim();

    if (property !== derivedProperty) {
      continue;
    }

    codePoints.add(codePointRange);
  }

  return codePoints;
}

function extractVersion(fileContents: string): string | null {
  return (
    fileContents.match(/DerivedCoreProperties-(\d+\.\d+\.\d+).txt/)?.[1] ?? null
  );
}

// Convert data to Rust and write to disk.

function writeRustFile({
  continueCodePoints,
  output,
  startCodePoints,
  version,
}: Readonly<{
  continueCodePoints: Set<string>;
  startCodePoints: Set<string>;
  output: string;
  version: string;
}>): void {
  console.info(`Creating file at: \`${output}\`...`);

  let data = getPragma(version);

  data += `
pub fn is_unicode_id_start(ch: char) -> bool {
\tmatch ch {
\t\t${getCodePoints(startCodePoints)} => true,
\t\t_ => false,
\t}
}

pub fn is_unicode_id_continue(ch: char) -> bool {
\tif is_unicode_id_start(ch) {
\t\treturn true;
\t}
\t  
\tmatch ch {
\t\t${getCodePoints(
    removeDuplicateCodePoints(startCodePoints, continueCodePoints)
  )} => true,
\t\t_ => false,
\t}
}
  `;

  fs.writeFile(path.join(__dirname, "..", output), data, (err) => {
    if (err) {
      throw err;
    }

    console.info(`Finished creating file at: \`${output}\`...`);
  });
}

function getCodePoints(codePoints: Set<string>): string {
  const formatted = [];

  for (const codePoint of codePoints) {
    if (codePoint.includes("..")) {
      const [start, end] = codePoint.split("..");

      formatted.push(`'\\u{${start}}'..='\\u{${end}}'`);
    } else {
      formatted.push(`'\\u{${codePoint}}'`);
    }
  }

  return formatted.join("\n\t\t| ");
}

function getPragma(version: string) {
  return `/**
 * This file is generated. Do not modify it manually!
 *
 * This file was generated by:
 *   scripts/generate-unicode-matchers.ts
 *
 * Unicode Version:
 *   ${version}
 */
`;
}

function removeDuplicateCodePoints(
  codePointsOne: Set<string>,
  codePointsTwo: Set<string>
): Set<string> {
  const output = new Set<string>();

  for (const codePoint of codePointsTwo) {
    if (!codePointsOne.has(codePoint)) {
      output.add(codePoint);
    }
  }

  return output;
}
